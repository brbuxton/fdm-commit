Index: requirements.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>requests~=2.23.0\r\nwebexteamssdk~=1.3\r\nurllib3~=1.25.9
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- requirements.txt	(revision 17d3c6a48abb18443da8a10c035058ef86c93e42)
+++ requirements.txt	(date 1591983962270)
@@ -1,3 +1,4 @@
 requests~=2.23.0
-webexteamssdk~=1.3
-urllib3~=1.25.9
\ No newline at end of file
+urllib3~=1.25.9
+webexteamsbot~=0.1.4.2
+pyngrok~=4.0.1
\ No newline at end of file
Index: fdmcommit.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import requests\r\nimport os\r\nimport logging.handlers\r\nimport urllib3\r\nfrom webexteamssdk import WebexTeamsAPI\r\n\r\n# setup log class\r\nlog = logging.getLogger(__name__)\r\nlog.setLevel(logging.DEBUG)\r\n# setup rotating logs\r\nfile_handler = logging.handlers.RotatingFileHandler('commit.log', maxBytes=1000000, backupCount=3)\r\nfile_handler.setLevel(logging.DEBUG)\r\n# setup console logging\r\nconsole_stream_handler = logging.StreamHandler()\r\nconsole_stream_handler.setLevel(logging.DEBUG)\r\n# setup time date formatting\r\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\r\nfile_handler.setFormatter(formatter)\r\nconsole_stream_handler.setFormatter(formatter)\r\n# attach file and console logging to the log class\r\nlog.addHandler(file_handler)\r\nlog.addHandler(console_stream_handler)\r\nurllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)\r\n\r\n\r\nclass FDM:\r\n    token = None\r\n\r\n    def __repr__(self):\r\n        return f'{self.__class__.__name__}'\r\n\r\n    def __init__(self):\r\n        log.debug(f'Initializing {FDM}')\r\n        self.user = os.getenv('USER')\r\n        self.pwd = os.getenv('PASS')\r\n        self.api = f\"https://{os.getenv('FDMADDRESS')}/api/fdm/latest\"\r\n        self.headers = {'Content-Type': 'application/json'}\r\n        if self.token is None:\r\n            self.get_token()  # TODO: check for token expiration\r\n            log.debug(f'{FDM} - Set token to {self.token}')\r\n\r\n    def get_token(self):\r\n        \"\"\"\r\n        Log into the FDM API with admin credentials stored in environment variables and get a token for subsequent\r\n        requests.  Add the Bearer token to the Authorization header.\r\n\r\n        :return: returns the current token for testing purposes.\r\n        \"\"\"\r\n        payload = f'''{{\r\n    \"grant_type\": \"password\",\r\n    \"desired_expires_in\": 1800,\r\n    \"desired_refresh_expires_in\":2400,\r\n    \"desired_refresh_count\": 0,\r\n    \"username\": \"{self.user}\",\r\n    \"password\": \"{self.pwd}\"\r\n}}'''\r\n        response = requests.post(self.api + '/fdm/token', headers=self.headers, data=payload, verify=False).json()\r\n        log.debug(f'get_token - response code')\r\n        FDM.token = response['access_token']  # This token is stored in the class for use by all instances\r\n        self.headers['Authorization'] = f'Bearer {self.token}'\r\n        return response['access_token']\r\n\r\n    def inspect_pending_changes(self):\r\n        '''\r\n        Pull a list of pending changes off the FTD and evaluate for intrusion rule, VDB and geolocation updates.\r\n        This method needs to be decomposed into a single task.  Right now it also deploys the changes if only intrusion\r\n        updates are present.\r\n\r\n        :return:\r\n        '''\r\n        response = requests.get(self.api + '/operational/pendingchanges', headers=self.headers, data=None,\r\n                                verify=False).json()\r\n        if False in {item['entityType'] in ('sruversion', 'intrusionpolicy') for item in response['items']}:\r\n            log.debug('non-SRU items in pendingchanges. Exiting.')\r\n            log.debug({item['entityType'] == 'sruversion' for item in response['items']})\r\n            log.debug((response['items']))\r\n            raise Exception('non-SRU items in pendingchanges')\r\n        elif True in {item['entityType'] in ('sruversion', 'intrusionpolicy') for item in response['items']}:\r\n            try:\r\n                response = requests.post(self.api + '/operational/deploy', headers=self.headers, data=None,\r\n                                         verify=False)\r\n                return\r\n            except:\r\n                raise Exception(f\"{self} - failed to deploy - {response}\")\r\n        elif len({item['entityType'] == 'sruversion' for item in response['items']}) == 0:\r\n            log.debug('no changes to deploy')\r\n            return\r\n        else:\r\n            raise Exception(f'non-True/False/zero in pendingchanges - {response}')\r\n\r\n\r\nif __name__ == '__main__':\r\n    fdm = FDM()\r\n    print(fdm.inspect_pending_changes())\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- fdmcommit.py	(revision 17d3c6a48abb18443da8a10c035058ef86c93e42)
+++ fdmcommit.py	(date 1591986996927)
@@ -2,7 +2,12 @@
 import os
 import logging.handlers
 import urllib3
-from webexteamssdk import WebexTeamsAPI
+
+from webexteamsbot import TeamsBot
+from webexteamsbot.models import Response
+
+from pyngrok.conf import PyngrokConfig
+from pyngrok import ngrok
 
 # setup log class
 log = logging.getLogger(__name__)
@@ -27,7 +32,7 @@
     token = None
 
     def __repr__(self):
-        return f'{self.__class__.__name__}'
+        return "{}({!r})".format(self.__class__.__name__, self.user, self.pwd, self.api, self.headers, self.token)
 
     def __init__(self):
         log.debug(f'Initializing {FDM}')
@@ -89,6 +94,74 @@
             raise Exception(f'non-True/False/zero in pendingchanges - {response}')
 
 
+class Teams:
+    def __repr__(self):
+        return "{}({!r})".format(self.__class__.__name__, self.public_url, self.files_url, self.api)
+
+    def __init__(self):
+        log.debug(f'Initializing {Teams}')
+        pyngrok_config = PyngrokConfig(auth_token=os.getenv("NGROK_TOKEN"))
+        self.public_url = ngrok.connect(port=5000, proto='http', pyngrok_config=pyngrok_config)
+        self.files_url = ngrok.connect(port=5001, proto='http', pyngrok_config=pyngrok_config)
+        self.api = TeamsBot(os.getenv("TEAMS_BOT_APP_NAME"),
+                            teams_bot_token=os.getenv("TEAMS_BOT_TOKEN"),
+                            teams_bot_url=self.public_url,
+                            teams_bot_email=os.getenv("TEAMS_BOT_EMAIL"),
+                            webhook_resource_event=[{"resource": "messages", "event": "created"},
+                                                    {"resource": "attachmentActions", "event": "created"}]
+                            )
+        self.api.add_command('/dosomething', 'help for do something', self.do_something)
+        self.api.add_command("/demo", "Sample that creates a Teams message to be returned.", self.ret_message)
+
+    def do_something(self, incoming_msg):
+        return f"it lives!! - {incoming_msg.text}"
+
+    def greeting(self, incoming_msg):
+        # Loopkup details about sender
+        sender = self.api.teams.people.get(incoming_msg.personId)
+
+        # Create a Response object and craft a reply in Markdown.
+        response = Response()
+        response.markdown = "Hello {}, I'm a chat bot. ".format(sender.firstName)
+        response.markdown += "See what I can do by asking for **/help**."
+        return response
+
+    def ret_message(self, incoming_msg):
+        """
+        Sample function that uses a Response object for more options.
+        :param attachment: The attachment to upload
+        :param incoming_msg: The incoming message object from Teams
+        :return: A Response object based reply
+        """
+        # Create a object to create a reply.
+        response = Response()
+
+        # Check for customer name.
+        try:
+            customer = incoming_msg.text.split(' ')[1]
+            pass
+        except:
+            response.text = "Customer name is blank.  Please provide a valid customer name."
+            return response
+        finally:
+            print('Finally')
+
+        # Set the text of the reply.
+        response.text = f"Here's a fun little meme. - {customer}"
+
+        # Craft a URL for a file to attach to message
+
+        attachment = None
+
+        if attachment == None:
+            u = "https://sayingimages.com/wp-content/uploads/"
+            u = u + "aaaaaalll-righty-then-alrighty-meme.jpg"
+        else:
+            u = self.files_url + attachment
+        response.files = u
+        return response
+
+
 if __name__ == '__main__':
     fdm = FDM()
     print(fdm.inspect_pending_changes())
